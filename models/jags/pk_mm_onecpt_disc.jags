model {
  # Priors (log-scale)
  logCL   ~ dnorm(mu_logCL,  tau_logCL)
  logVc   ~ dnorm(mu_logVc,  tau_logVc)
  logVmax ~ dnorm(mu_logVmax, tau_logVmax)
  logKm   ~ dnorm(mu_logKm,  tau_logKm)

  CL   <- exp(logCL)
  Vc   <- exp(logVc)
  Vmax <- exp(logVmax)
  Km   <- exp(logKm)

  # Residual error parameters
  sigma_add_free ~ dunif(1.0E-6, 1000)
  sigma_add <- est_sigma * sigma_add_free + (1 - est_sigma) * sigma_init
  tau_add <- pow(sigma_add, -2)
  sigma_prop ~ dunif(0, 5)
  # t df
  nu ~ dunif(2, 60)
  # Mixture (two normals)
  pi_mix ~ dbeta(pi_mix_alpha, pi_mix_beta)
  kappa ~ dunif(1.0, 10.0)
  tau_mix1 <- tau_add
  tau_mix2 <- pow(sigma_add * kappa, -2)

  # ODE (Euler) over adaptive grid
  C[1] <- C0
  for (i in 1:(Nt - 1)) {
    input <- rate[i] / Vc
    elim_lin <- (CL / Vc) * C[i]
    elim_mm  <- (Vmax / Vc) * C[i] / (Km + C[i])
    dCdt <- input - elim_lin - elim_mm
    C[i+1] <- max(1.0E-12, C[i] + dt[i] * dCdt)
  }

  # Observation model; y contains NA for censored points
  for (n in 1:N) {
    mu[n] <- C[idx[n]]
    if (error_model == 1) {
      # additive normal
      is_int[n] ~ dinterval(y[n], lloq[n])  # 0 if y < LLOQ
      y[n] ~ dnorm(mu[n], tau_add)
    } else if (error_model == 2) {
      # proportional normal
      tau_n[n] <- pow(sigma_prop * mu[n] + 1.0E-12, -2)
      is_int[n] ~ dinterval(y[n], lloq[n])
      y[n] ~ dnorm(mu[n], tau_n[n])
    } else if (error_model == 3) {
      # combined normal
      sigma_c[n] <- sqrt(pow(sigma_add,2) + pow(sigma_prop * mu[n], 2))
      tau_n[n] <- pow(sigma_c[n], -2)
      is_int[n] ~ dinterval(y[n], lloq[n])
      y[n] ~ dnorm(mu[n], tau_n[n])
    } else if (error_model == 4) {
      # t-additive
      is_int[n] ~ dinterval(y[n], lloq[n])
      y[n] ~ dt(mu[n], tau_add, nu)
    } else if (error_model == 5) {
      # t-proportional
      tau_n[n] <- pow(sigma_prop * mu[n] + 1.0E-12, -2)
      is_int[n] ~ dinterval(y[n], lloq[n])
      y[n] ~ dt(mu[n], tau_n[n], nu)
    } else {
      # mixture normals
      z[n] ~ dbern(pi_mix)
      tau_z[n] <- equals(z[n],0) * tau_mix1 + equals(z[n],1) * tau_mix2
      is_int[n] ~ dinterval(y[n], lloq[n])
      y[n] ~ dnorm(mu[n], tau_z[n])
    }
  }
}
